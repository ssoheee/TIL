## R

R은 컴퓨터 언어이자 다양한 패키지의 집합이다. 따라서 R 안에서 대부분의 데이터 분석을 해낼 수 있다는 장점이 있다. R은 통계, 기계 학습, 금융, 생물정보학, 그래픽스에 이르는 다양한 통계 패키지를 갖추고 있으며 이 모든 것이 무료로 제공된다. 

rstudio.com 설치

= 대신 <- 사용

마지막 라인은 ; 쓰면 안됨

run은 라인단위로 실행, source는 마지막으로 실행

```
install.packages("randomForest") 콘솔에서 설치 가능
```



### 변수 이름 규칙

R의 변수명은 알파벳, 숫자, _(언더스코어), .(마침표)로 구성되며, -(하이픈)은 사용할 수 없다. 첫 글자는 알파벳 또는 .으로 시작해야 한다. 만약 .으로 시작한다면 . 뒤에는 숫자가 올 수 없다. 

### 변숫값 할당

변수에 값을 할당할 때는 <-, <<- 또는 = 연산자를 사용한다. <-와 <<-는 뒤에서 설명하겠지만 어느 스코프scope에 있는 변수에 값을 할당하는지에 차이가 있다. 그러나 <-와 =는 대부분의 경우에 바꿔서 사용할 수 있고, 따라서 둘 중 어느 것을 사용해야 하는지는 다소 논쟁적인 주제다. 이 책에서는 <- 연산자를 사용했는데, 그 이유 중 하나는 =는 때에 따라 사용할 수 없는 경우가 있기 때문이다.

*<Note>* <-와 =의 차이

------

할당 연산자 중 =는 명령의 최상위 수준에서만 사용할 수 있는 반면 <-는 어느 곳에서나 사용할 수 있다. 따라서 함수 호출과 동시에 변수에 값을 할당하는 목적으로는 <-만 사용할 수 있다. 다음은 1, 2, 3을 저장한 벡터를 x에 할당한 후 이 값들의 평균을 구하고 x에 저장된 값을 출력한 예다.

```
  > mean(x <- c(1, 2, 3))
  [1] 2
  > x
  [1] 1 2 3
```

같은 상황에서 =를 사용하면 x에 값이 저장되지 않는다.

```
  > mean(x = c(1, 2, 3))
  [1] 2
  > x
  Error: object 'x' not found
  >
```

이 차이 때문에 =를 사용하면 경우에 따라 표현력에 한계가 있을 수 있다.

### NA

R과 다른 언어의 가장 큰 차이 중 하나가 바로 NANot Available 상수다. NA는 데이터 값이 없음을 뜻한다. 

c <- NA;
print(is.na(c));

-> 콘솔에 true라고 찍힘

*<Note>* NULL과 NA의 차이

------

NA는 결측치, 즉 값이 빠져 있는 경우를 뜻한다. 결측치가 존재하는 이유로는 데이터 입력 중 실수로 값을 입력하지 않은 경우, 값을 어떤 이유로든 관찰되지 못한 경우(예를 들어, 인구 조사에서 특정 가구가 소득을 기재하지 않은 경우), 마지막으로 해당 항목에 적절한 값이 없어서 값이 입력되지 않은 경우(예를 들어, 약품의 냄새를 기록하고 있는 칸에서 특정 약품은 향이 없는 경우)를 들 수 있다.

반면 NULL은 프로그래밍의 편의를 위해 미정(undefined) 값을 표현하는 데 사용하는 개념이다.

### 벡터 생성

벡터는 c( )를 사용해 생성하고, names( )를 사용해 이름을 부여할 수 있다. 

score <- c(100,90,80)
names(score) <- c("lee","kim","han")
print(sum(score)) 

결과 : 270

v1 <- c(1:10)
print(v1[-1])

결과 :   2  3  4  5  6  7  8  9 10

v1 <- c(10:20)
print(v1[5:8])

결과 :   14 15 16 17

```
> x <- c("a", "b", "c")
> length(x)
[1] 3
> nrow(x)  # nrow()는 행렬만 가능
NULL
> NROW(x)  # NROW()는 벡터와 행렬 모두 사용 가능
[1] 3
```

두 벡터가 같은 값을 담고 있는지는 identical( ) 함수로 알 수 있다.

%in% 연산자는 어떤 값이 벡터에 포함되어 있는지를 알려준다.

a <- c(1:10)
b <- seq(1,10)

결과 :  [1]  1  2  3  4  5  6  7  8  9 10
            [1]  1  2  3  4  5  6  7  8  9 10

##  리스트

a <- list(name=c("a","b","c","d"),score=c(90,100,80,30))
print(a[1])

결과 : $name
[1] "a" "b" "c" "d"

a <- list(name=c("a","b","c","d"),score=c(90,100,80,30))
print(a$name[1])

결과 : "a"

a <- list(s1=c(80,90,70,88),s2=c(90,100,80,30))
print(mean(a$s1))
print(mean(a$s2))
print(mean(c(a$s1,a$s2)))

print(a$s1[c(1,4)]) (두 개 이상을 가져올 땐 꼭 c 쓰기)

print(mean(a$s1[c(1:3)])) (1-3번째 평균)



* MATRIX는 행이 먼저

* ma <- matrix(c(1:6),nrow=3)
  print(nrow(ma))
  print(ncol(ma))

* 결과

  [1] 3
  [1] 2

  

data <- c(1:9)
ma <- matrix(data)
print(ma)

결과

      [,1]
 [1,]    1
 [2,]    2
 [3,]    3
 [4,]    4
 [5,]    5
 [6,]    6
 [7,]    7
 [8,]    8
 [9,]    9



data <- c(1:9)
ma <- matrix(data,nrow=3)
print(ma)

결과 

     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9



data <- c(1:9)
ma <- matrix(data,nrow=3,byrow=TRUE)
print(ma)

결과

     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9



data <- c(1:9)
ma <- matrix(data,nrow=3)
rownames(ma) <- c("r1","r2","r3")
colnames(ma) <- c("c1","c2","c3")
print(ma)

결과

   c1 c2 c3
r1  1  4  7
r2  2  5  8
r3  3  6  9



data <- c(1:9)
ma <- matrix(data,nrow=3)
rownames(ma) <- c("r1","r2","r3")
colnames(ma) <- c("c1","c2","c3")
print(ma[c(2:3),c(2:3)])

결과

   c2 c3
r2  5  8
r3  6  9



r2와 c3의 평균을 구하시오

print(mean(ma[2,c(1:3)]))  =   print(mean(ma[2,]))

print(mean(ma[c(1:3),3]))  =   print(mean(ma[,3]))

 

1. scalar

2. factor

3. vector

4. list (key value)

5. matrix (중요) -> 한가지 타입만 들어간다.

6. dataframe - 다양한 타입이 들어간다.

   데이터 프레임Data Frame은 처리할 데이터를 마치 엑셀의 스프레드시트와 같이 표 형태로 정리한 모습을 하고 있다. 데이터 프레임의 각 열에는 관측값의 이름이 저장되고, 각 행에는 매 관측 단위마다 실제 얻어진 값이 저장된다. 

   이처럼 자연스럽게 데이터를 표현하는 데이터 타입이기 때문에 데이터 프레임은 R에서 가장 중요한 데이터 타입이며, 많은 R 함수에서 인자로 데이터 프레임을 받는다.



dfi <- data.frame(x=c(1:5),y=c(6:10),z=c(11:15))
print(dfi)

결과

  x  y  z
1 1  6 11
2 2  7 12
3 3  8 13
4 4  9 14
5 5 10 15



df1 <- data.frame(x=c(1:5),y=c(6:10),z=c(11:15))
print(df1$x)
print(df1[2,])
print(df1$x[3])
print(df1[3,1])
print(df1["x"])
print(df1[,2])

결과

[1] 1 2 3 4 5
  x y  z
2 2 7 12
[1] 3
[1] 3
  x
1 1
2 2
3 3
4 4
5 5
[1]  6  7  8  9 10



2.2부터 5.3까지 컷팅하시오

df2=df1[c(2:5),c(2:3)]
print(df2)

결과

   y  z
2  7 12
3  8 13
4  9 14
5 10 15







df1 <- data.frame(
  "lee" =c(90,99,89,87),
  "kim" =c(91,95,87,56),
  "han" =c(60,89,59,87),
  "jun" =c(90,65,69,77),
  "goo" =c(90,98,89,87)
)

학생별 평균과 전체 평균을 구하시오

each1 <- c(mean(df1[,1]),mean(df1[,2]),mean(df1[,3]),mean(df1[,4]),mean(df1[,5]))
print(mean(each1))



df1 <- data.frame(
  "lee" =c(90,99,89,87),
  "kim" =c(91,95,87,56),
  "han" =c(60,89,59,87),
  "jun" =c(90,65,69,77),
  "goo" =c(90,98,89,87),
  "grade" =c("a","b","c","d")
)

df1$lee <- c(0,0,0,0)
df1$hong <- c(100,100,100,100)
print(df1)

결과

  lee kim han jun goo grade hong
1   0  91  60  90  90     a  100
2   0  95  89  65  98     b  100
3   0  87  59  69  89     c  100
4   0  56  87  77  87     d  100



df1 <- data.frame(
  a = c(1:4),
  b = c(5:8),
  c = c(9:12),
  d=c("A","B","A","B")
)
df2 <- df1[,-4]
print(df2)

결과

  a b  c
1 1 5  9
2 2 6 10
3 3 7 11
4 4 8 12



print(class(df3)) -> 타입을 알려줌





## R의 특징

첫째는 데이터를 다루는 방법이다. 다른 프로그래밍 언어에서는 흔히 for 문을 사용해 데이터를 한 행씩 읽어들여 처리한다. 하지만 R에서는 전체 데이터를 한 번에 다루는 벡터 연산을 더 자주 사용한다. 

둘째는 결측치NA다. R에는 초기화되지 않은 변수에 저장하는 NULL 외에도 관측 또는 기록되지 않은 데이터를 표시하기 위한 NA가 있다. 따라서 코드에서 NA를 제대로 구분해서 처리하지 않으면 원하는 결과를 얻지 못할 수도 있다. 

셋째는 객체의 불변성이다. 대부분의 R 객체는 그 값을 수정할 수 없다. 따라서 문법적으로 객체의 데이터를 수정하고 있다고 보이는 코드에서도 실제로는 해당 부분의 값이 수정된 새로운 객체가 생성된다.



### 수치 연산

+, -, *, /

사칙 연산

n %% m

n을 m으로 나눈 나머지

n %/% m

n을 m으로 나눈 몫

n^m

n의 m승

exp(n)

e의 n승

log(x, base=exp(1))

logbase(x). 만약 base가 지정되지 않으면 loge(x)를 계산

log2(x), log10(x)

각각 log2(x), log10(x)를 계산

sin(x), cos(x), tan(x)

삼각 함수



### NA 처리

```
na.rm=TRUE
```



n <- 100
f1 <- function(){
  n <<- 1           // n을 전역변수 값으로 아예 바꿔버리는 것
  return (n)
}

print(f1())



list=ls() 메모리에 저장된 모든 변수들을 불러옴 -> rm(list=ls()) 지우는 법